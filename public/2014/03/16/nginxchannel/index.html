<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>nginx中channel机制 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta content="article" property="og:type">
<meta content="nginx中channel机制" property="og:title">
<meta content="http://yoursite.com/2014/03/16/nginxchannel/" property="og:url">
<meta content="/assets/post/2014-03-16-nginxchannel/nginx_channel.png" property="og:image">
<meta content="Hexo" property="og:site_name">
<meta content="1.概述
2.worker进程的创建
3.nginx频道
4.master写入与worker读取数据 
5.nginx中channel指令" property="og:description">
<meta content="summary" name="twitter:card">
  
    <link rel="alternative" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link href="http://fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/css/style.css" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  
</head>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><input type="submit" value="&#xF002;" class="search-form-submit"><input type="hidden" name="q" value="site:http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-nginxchannel" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/03/16/nginxchannel/" class="article-date">
  <time datetime="2014-03-16T00:00:00.000Z" itemprop="datePublished">Mar 16 2014</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/nginx源码学习/">nginx源码学习</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      nginx中channel机制
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <ul>
<li><a href="#abstract">1.概述</a></li>
<li><a href="#worker">2.worker进程的创建</a></li>
<li><a href="#siginit">3.nginx频道</a></li>
<li><a href="#read">4.master写入与worker读取数据</a> </li>
<li><a href="#channelcmd">5.nginx中channel指令</a><a id="more"></a>
</li>
</ul>
<hr>
<h3 id="abstract"><a>1.概述</a></h3><br>由于nginx使用的是多进程的模型，因此，进程间的通信或者同步很重要，为什么要进行进程同步呢？我们知道，nginx有master和worker进程，在上篇文章已经分析过了master具体是怎样创建worker进程的。不过，在创建worker进程的时候，是需要对进程同步的。举个具体的例子，我们假设服务器共有4个worker进程，我们知道nginx有一个全局变量，是ngx_processes数组，他存储着所有进程的信息，在worker1创建的时候，worker2，worker3，worker4进程是没有创建的，因此，这个时候就牵扯到同步，最合理的方式是，在master创建一个进程的时候，就应该通知所有子进程有新的进程被fork了，以及这个进程的基本信息。<br><br>这个好比一个集体(由很多processes组成)，当有新的成员加入这个集体的时候，老大应该告诉大伙，有新成员进来了，他的基本信息是balabala。因此，也就引出了本文所要总结的内容，即nginx的进程通信机制。<br><br>———-<br><br><h3 id="worker"><a>2.worker进程的创建</a></h3><br>我们先回顾一下worker进程的创建过程，ngx_master_process_cycle -&gt; ngx_start_worker_processes，在 <code>ngx_start_worker_processes</code> 函数中，有下面的代码<br><br><br>    static void<br>    ngx_start_worker_processes(ngx_cycle_t <em>cycle, ngx_int_t n, ngx_int_t type)<br>    {<br>        ngx_int_t      i;<br>        ngx_channel_t  ch;<br><br>        ngx_log_error(NGX_LOG_NOTICE, cycle-&gt;log, 0, “start worker processes”);<br><br>        ch.command = NGX_CMD_OPEN_CHANNEL;<br><br>        for (i = 0; i &lt; n; i++) {<br><br>            ngx_spawn_process(cycle, ngx_worker_process_cycle,<br>                              (void </em>) (intptr_t) i, “worker process”, type);<br><br>            ch.pid = ngx_processes[ngx_process_slot].pid;<br>            ch.slot = ngx_process_slot;<br>            ch.fd = ngx_processes[ngx_process_slot].channel[0];<br><br>            ngx_pass_open_channel(cycle, &amp;ch);<br>        }<br>    }<br><br><br>注意观察下， <code>ngx_channel_t</code> 结构体的定义如下：<br><br><br>    typedef struct {<br>         ngx_uint_t  command;<br>         ngx_pid_t   pid;<br>         ngx_int_t   slot;<br>         ngx_fd_t    fd;<br>    } ngx_channel_t;<br><br><br>没错，这个就是master与worker进程通信的最重要的结构，短小精汗。<br><br>该结构封装了四个变量，分别是指令(master要worker干啥)，pid(worker的进程id)，slot(worker进程在ngx_processes的索引)，文件描述符。我们思考一下概述中的那个问题，怎么将master后创建的进程通知前面已创建的进程。 <code>ngx_pass_open_channel(cycle, &amp;ch);</code> 注意一下这个函数，没错就是它了，通过它对每个进程进行通知。<br><br>—————<br><br><h3 id="channel"><a>3.nginx频道</a></h3><br>那么具体又是怎么实现通知的呢？我们看到在 <code>ngx_channel_t</code> 中有一个 <code>ngx_fd_t    fd;</code> 这个文件描述便存储着通信的“接口”，从之前的代码我们看出来， <code>ch.fd = ngx_processes[ngx_process_slot].channel[0];</code> 这个channel[0]是真正传输的接口。那么他是什么呢？简单的说，就是master写给每个process的channel[0]一些信息(ngx_channel_t的实际内容)，worker就能在自己的channel[1]中，读取到这些信息。<br><br>nginx使用的是 <code>socketpair</code> 方法关联套接字，我们看看socketpair的原型：<br><br>    int socketpair(int d, int type, int protocol, int sv[2]);<br><br><br>我们关注一下第四个参数，当这个socketpair函数执行成功后，就会生成一个socket对在数组中，sv[2]中的socket是关联起来的，什么意思呢？就是说向sv[0]写数据，在sv[1]就能读到相应的数据；相反的，在sv[1]写数据，在sv[0]也可以读到相应的数据。在master进程fork worker进程的时候，也把这个套接字传给了worker，也就是说在master向worker的sv[0]写数据，那么worker便可以在自己的sv[1]中读到数据。<br><br><img src="/assets/post/2014-03-16-nginxchannel/nginx_channel.png" alt="nginx_channel"><br><br>nginx的具体的实现方式如上图所示：<br>channel[0]和channel[0]为一对socketpair。<br><br>    1. 向channel[0]写数据时，可从channel[1]读数据；<br>    2. 向channel[1]写数据时，可从channel[0]读数据。<br><br>而nginx，只利用了第一条，即master向channel[0]写数据时，worker可从channel[1]读数据<br>socketpair也用来进行父子进程的通信，子进程会继承父进程的资源。<br><br><br><h3 id="read"><a>4.master写入与worker读取数据</a></h3>

<p>我们具体的来看下nginx写入数据的过程，</p>
<pre><code><span class="tag">ngx_write_channel</span>(<span class="tag">ngx_processes</span><span class="attr_selector">[i]</span><span class="class">.channel</span><span class="attr_selector">[0]</span>,
                          <span class="tag">ch</span>, <span class="tag">sizeof</span>(<span class="tag">ngx_channel_t</span>), <span class="tag">cycle-</span>&gt;<span class="tag">log</span>);
</code></pre><p>和上节介绍的一样，我们看到master对每一个ngx_processes[i].channel[0]写入数据。并且写入的数据就是 <code>ngx_channel_t</code> 变量。<br>好了，既然master向worker写数据的接口有了，那么woker又怎么对master写入的数据进行读取和处理呢？</p>
<p>我们目光移到worker进程上面，ngx_worker_process_cycle函数，在初始化时，调用了 <code>ngx_worker_process_init</code> 函数，这个初始化函数又调用了</p>
<pre><code><span class="function"><span class="title">ngx_add_channel_event</span><span class="params">(cycle, ngx_channel, <span class="variable">NGX_READ_EVENT</span>,ngx_channel_handler)</span></span>
</code></pre><p>这个就利用了nginx强大的事件机制，这个函数大概的功能就是，如果worker channel[1]有可读的数据，便会调用  <code>ngx_channel_handler</code>  进行处理。</p>
<pre><code><span class="keyword">switch</span> (ch.command) {

case NGX_CMD_QUIT:
    ngx_quit = <span class="number">1</span>;
    <span class="keyword">break</span>;

case NGX_CMD_TERMINATE:
    ngx_terminate = <span class="number">1</span>;
    <span class="keyword">break</span>;

case NGX_CMD_REOPEN:
    ngx_reopen = <span class="number">1</span>;
    <span class="keyword">break</span>;

case NGX_CMD_OPEN_CHANNEL:
    <span class="keyword">...</span>
    ngx_processes[ch.slot].pid = ch.pid;
    ngx_processes[ch.slot].channel[<span class="number">0</span>] = ch.fd;
    <span class="keyword">break</span>;

case NGX_CMD_CLOSE_CHANNEL:
    <span class="keyword">...</span>
    <span class="keyword">if</span> (close(ngx_processes[ch.slot].channel[<span class="number">0</span>]) == -<span class="number">1</span>) {
        ngx_log_error(NGX_LOG_ALERT, ev-&gt;log, ngx_errno,
                      <span class="string">"close() channel failed"</span>);
    }

    ngx_processes[ch.slot].channel[<span class="number">0</span>] = -<span class="number">1</span>;
    <span class="keyword">break</span>;

case NGX_CMD_PIPE_BROKEN:
    ngx_pipe_broken_action(ev-&gt;log, ch.pid, <span class="number">0</span>);
    <span class="keyword">break</span>;
}
</code></pre><p>由于nginx目前的读写数据只是单向的即mater—&gt;worker，因此，这些指令的解析，都是需要让worker做一些事儿。我们可以关注一下 <code>NGX_CMD_OPEN_CHANNEL</code> 这个分支。在ngx_start_worker_processes函数中，master就向worker写入了 <code>NGX_CMD_OPEN_CHANNEL</code> 指令。</p>
<p>那么worker进程，便根据这个 <code>ngx_channel_t ch</code> 信息，更新processes数组。这样便完成了进程的同步。</p>
<hr>
<p><h3 id="channelcmd"><a>5.nginx中channel指令</a></h3><br>我们发现，ngx_channel_handler中共有6个指令类型，分别是NGX_CMD_QUIT、NGX_CMD_TERMINATE、NGX_CMD_REOPEN、NGX_CMD_OPEN_CHANNEL、NGX_CMD_CLOSE_CHANNEL、NGX_CMD_PIPE_BROKEN。下面我们分析下，和channel相关的命令。</p>
<p><code>NGX_CMD_OPEN_CHANNEL</code><br>之前，我们已经分析了NGX_CMD_OPEN_CHANNEL信号的解析大致过程，现在仔细观察一下，我先搜索了一下使用<code>NGX_CMD_OPEN_CHANNEL</code>命令的地方，对<code>ch.command</code>赋值的地方有四处。第一处是用于worker进程的，第二、三处是和cache manager进程有关的，暂不关注，第四处，是<code>ngx_reap_children</code>主要是用于nginx重启后，重新开启channel的。</p>
<p>我们只分析第一处，master进程的函数<code>ngx_start_worker_processes</code> 在开启worker进程的时候，把命令设置为<code>NGX_CMD_OPEN_CHANNEL</code>，并且通过<code>ngx_write_channel</code>把指令给相应的进程，这样当worker进程解析这个消息时，便根据新进程的slot把新进程的信息(新进程的pid、新进程的channel[0])保存起来。<br><img src="/assets/post/2014-03-16-nginxchannel/nginx_open_channel.png" alt="nginx_open_channel"></p>
<p>上图已经表明了<code>NGX_CMD_OPEN_CHANNEL</code>的传递与生效过程。<br>分为2个部分</p>
<ol>
<li>Master部分。<br> 第一步，由Master进程创建socket pair，即创建channel，利用socketpair函数，master进程processes数组中存储了master与新的work的channel信息。<br> 第二步，2. Fork的子进程会继承父进程，Fork子进程，利用fork函数，子进程会继承父进程的资源。<br> 第三步，3. 利用ngx_pass_open_channel向各进程发送NGX_CMD_OPEN_CHANNEL，通知其他进程信息更新。<br>2.Worker部分。<br> 第一步，关闭除自己以外的channel[1]。<br> 第二步，关闭自己的channel[0]。</li>
</ol>
<p>总结一下，这个命令就是告诉worker，有新的进程来，他OPEN_CHANNEL了，你得存起来，然后worker就存这个新进程的信息了，当然这个信息是存在processes数组里了。</p>
<p><code>NGX_CMD_CLOSE_CHANNEL</code><br>当然，与打开对应的就是关闭channel指令了，与这个命令相关的赋值只有一处，就是<code>ngx_reap_children</code>，当然就是master向每个进程更新信息，如果发现某个进程exited了，就告诉大家，可以把它的channel关闭了，即把这个channel的flag置为-1。而关闭的时候，<code>close(ngx_processes[ch.slot].channel[0])</code>关闭了channel[0]，先开始有疑问了，为什么只关0呢？1怎么办？原来1其实在work刚开始的时候就关闭了，即最开始就已经“关闭了除了自己外的channel[1]，然后再关闭自己的channel[0]。</p>
<p>总结一下，这个命令就是告诉work，你要关闭这个CHANNEL了，原因从目前的nginx代码来看，只有一个，就是需要重启。关闭已经exited的进程的channel。</p>
<p>不过，有些疑问，</p>
<p>1.目前来看只有master向worker的消息，不存在worker向master，或者worker向worker写了，那么为什么不关闭其他worker的channel[0]呢？我觉得可能是不是和cache load进程有关，后面再思考一下。</p>
<p>2.为什么master中要保留所有子进程channel[1]？可以在fork完子进程，就关闭，为什么不关闭呢？</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2014/03/16/nginxchannel/" data-id="4thufwkk9kkfvupg" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2014/03/19/vim/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          我的vim配置
        
      </div>
    </a>
  
  
    <a href="/2014/03/13/nginxstart/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">nginx启动流程分析</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/In XiDian/">In XiDian</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux Skill/">Linux Skill</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Some record/">Some record</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/nginx源码学习/">nginx源码学习</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/vim/">vim</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/算法学习/">算法学习</a><span class="category-list-count">1</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/About Blog/">About Blog</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Minds/">Minds</a><span class="tag-list-count">6</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/About Blog/" style="font-size: 10.00px;">About Blog</a><a href="/tags/Minds/" style="font-size: 20.00px;">Minds</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/04">April 2014</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/03">March 2014</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/02">February 2013</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/12">December 2012</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/11">November 2012</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2011/05">May 2011</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2011/03">March 2011</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2010/10">October 2010</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2010/07">July 2010</a><span class="archive-list-count">1</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recents</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2014/04/18/minheap/">最小堆</a>
          </li>
        
          <li>
            <a href="/2014/04/17/nginxconnections/">nginx的连接池</a>
          </li>
        
          <li>
            <a href="/2014/04/01/nginxaccept/">nginx建立连接过程分析</a>
          </li>
        
          <li>
            <a href="/2014/03/26/nginxevent/">nginx的事件主体分析</a>
          </li>
        
          <li>
            <a href="/2014/03/21/nginxeventinit/">nginx的事件初始化与框架</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2014 John Doe<br>
      Powered by <a href="http://zespia.tw/hexo/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>


<script type="text/javascript" src="/js/script.js"></script>
  </div>
</body>
</html>