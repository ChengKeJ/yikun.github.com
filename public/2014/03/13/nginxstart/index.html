<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>nginx启动流程分析 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta content="article" property="og:type">
<meta content="nginx启动流程分析" property="og:title">
<meta content="http://yoursite.com/2014/03/13/nginxstart/" property="og:url">
<meta content="/assets/post/2014-03-13-nginxstart/nginx_start.png" property="og:image">
<meta content="Hexo" property="og:site_name">
<meta content="1.解析命令参数。
2.初始化工作
3.信号处理的初始化
4.守护进程 
5.ngx_master_process_cycle，mater干的活
6.master开始工作
7.ngx_worker_process_cycle，worker开始工作


最近，开始学习nginx的代码，大致根据阿里数据平台的一些文章，加上Tengine 2.0的代码来看的。这次看代码主要是了解一下nginx的基本框" property="og:description">
<meta content="summary" name="twitter:card">
  
    <link rel="alternative" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link href="http://fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/css/style.css" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  
</head>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><input type="submit" value="&#xF002;" class="search-form-submit"><input type="hidden" name="q" value="site:http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-nginxstart" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/03/13/nginxstart/" class="article-date">
  <time datetime="2014-03-13T00:00:00.000Z" itemprop="datePublished">Mar 13 2014</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/nginx源码学习/">nginx源码学习</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      nginx启动流程分析
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <ul>
<li><a href="#getopt">1.解析命令参数。</a></li>
<li><a href="#init">2.初始化工作</a></li>
<li><a href="#siginit">3.信号处理的初始化</a></li>
<li><a href="#daemon">4.守护进程</a> </li>
<li><a href="#ngx_master_process_cycle">5.ngx_master_process_cycle，mater干的活</a></li>
<li><a href="#ngx_master">6.master开始工作</a></li>
<li><a href="#ngx_worker">7.ngx_worker_process_cycle，worker开始工作</a></li>
</ul>
<hr>
<p>最近，开始学习nginx的代码，大致根据<a href="http://www.alidata.org/archives/category/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8" target="_blank">阿里数据平台</a>的一些文章，加上Tengine 2.0的代码来看的。这次看代码主要是了解一下nginx的基本框架和主要工作流程。<br><a id="more"></a><br>如下图所示，为总的启动流程分析，后面是我对每个部分的总结和分析<br><img src="/assets/post/2014-03-13-nginxstart/nginx_start.png" alt="启动流程分析"></p>
<hr>
<h3 id="getopt"><a>1.解析命令参数。</a></h3>

<p>nginx是由C语言写成的，因此，从main函数开始开启我们的“旅程”，传入参数为argc，还有argv，最开始的任务当然就是解析它们了，以获得用户启动的参数，调用ngx_get_options解析参数，一般情况，Linux的解析命令参数都会调用getopt之类的系统函数，而nginx却没有，应该是考虑到了跨平台性。解析命令参数的代码比较简单，大致的工作就是标记flag，类似ngx_show_version，ngx_show_modules的全局参数可以记录命令参数。<br>而后，根据这些flag来做一些事情，例如使用nginx -h，会将ngx_show_version，ngx_show_help置为有效(1)，然后后面回到main后，就是做一些对应的输出。</p>
<hr>
<h3 id="init"><a>2.初始化工作。</a></h3>


<p>包括了time、regex、log、ssl等初始化，而后进行一个很重要的结构的初始化ngx_cycle。</p>
<pre><code><span class="keyword">struct</span> ngx_cycle_s {
    <span class="keyword">void</span>                  ****conf_ctx;                        <span class="comment">//配置上下文数组(含所有模块)</span>
    ngx_pool_t               *pool;                        <span class="comment">//内存池</span>

    ngx_log_t                *<span class="built_in">log</span>;                        <span class="comment">//日志</span>
    ngx_log_t                 new_log;

    ngx_connection_t        **files;                        <span class="comment">//连接文件</span>
    ngx_connection_t         *free_connections;                    <span class="comment">//空闲连接</span>
    ngx_uint_t                free_connection_n;                <span class="comment">//空闲连接个数</span>

    ngx_queue_t               reusable_connections_queue;            <span class="comment">//再利用连接队列</span>

    ngx_array_t               listening;                    <span class="comment">//监听数组</span>
    ngx_array_t               paths;                        <span class="comment">//路径数组</span>
    ngx_list_t                open_files;                    <span class="comment">//打开文件链表</span>
    ngx_list_t                shared_memory;                    <span class="comment">//共享内存链表</span>

    ngx_uint_t                connection_n;                    <span class="comment">//连接个数</span>
    ngx_uint_t                files_n;                        <span class="comment">//打开文件个数</span>

    ngx_connection_t         *connections;                    <span class="comment">//连接</span>
    ngx_event_t              *read_events;                    <span class="comment">//读事件</span>
    ngx_event_t              *write_events;                    <span class="comment">//写事件</span>

    ngx_cycle_t              *old_cycle;                    <span class="comment">//old cycle指针</span>

    ngx_str_t                 conf_file;                    <span class="comment">//配置文件</span>
    ngx_str_t                 conf_param;                    <span class="comment">//配置参数</span>
    ngx_str_t                 conf_prefix;                    <span class="comment">//配置前缀</span>
    ngx_str_t                 prefix;                        <span class="comment">//前缀</span>
    ngx_str_t                 lock_file;                    <span class="comment">//锁文件</span>
    ngx_str_t                 hostname;                        <span class="comment">//主机名</span>
};
</code></pre><p>ngx_init_cycle的过程的详细情况可以参考<a href="http://www.alidata.org/archives/1148" target="_blank">Nginx启动初始化过程(二)</a>。因为现在功力不是很深，等以后对nginx有透彻了解后，再仔细分析。这里第一次出现了内存池的操作，后面重点分析一下内存池的实现。</p>
<hr>
<h3 id="siginit"><a>3.信号处理的初始化</a></h3>

<p>ngx_init_signals会进行信号处理的初始化，signals是一个结构体数组，存储着各种信号的结构体，在初始化的过程中，会利用sigaction函数对每个信号进行设置，如下所示，主要是对signo和handler回调函数进行设置。初始化成功以后，当信号产生以后，便可以调用信号处理函数了，因此可以利用ngx_signal_handler进行信号处理了。</p>
<pre><code>ngx_int_t
ngx_init_signals(ngx_log_t *log)
{
    ngx_signal_t      *<span class="keyword">sig</span>;
    <span class="keyword">struct</span> sigaction   sa;

    <span class="keyword">for</span> (<span class="keyword">sig</span> = signals; <span class="keyword">sig</span>-&gt;signo != <span class="number">0</span>; <span class="keyword">sig</span>++) {
        ngx_memzero(&amp;sa, sizeof(<span class="keyword">struct</span> sigaction));
        sa.sa_handler = <span class="keyword">sig</span>-&gt;handler;
        sigemptyset(&amp;sa.sa_mask);
        <span class="keyword">if</span> (sigaction(<span class="keyword">sig</span>-&gt;signo, &amp;sa, NULL) == -<span class="number">1</span>) {
            ngx_log_error(NGX_LOG_EMERG, log, ngx_errno,
                          <span class="string">"sigaction(%s) failed"</span>, <span class="keyword">sig</span>-&gt;signame);
            <span class="keyword">return</span> NGX_ERROR;
        }
    }

    <span class="keyword">return</span> NGX_OK;
}
</code></pre><hr>
<h3 id="daemon"><a>4.守护进程</a></h3>

<p>在启动过程中，会调用ngx_daemon(cycle-&gt;log)，这个函数实现的很经典。</p>
<pre><code>ngx_int_t
ngx_daemon(ngx_log_t *<span class="built_in">log</span>)
{
    <span class="keyword">int</span>  fd;
    <span class="comment">//父进程fork</span>
    <span class="keyword">switch</span> (fork()) {
    <span class="comment">//fork执行完后，master的</span>
    <span class="keyword">case</span> -<span class="number">1</span>:
        <span class="comment">//fork出错了</span>
        ngx_log_error(NGX_LOG_EMERG, <span class="built_in">log</span>, ngx_errno, <span class="string">"fork() failed"</span>);
        <span class="keyword">return</span> NGX_ERROR;
    <span class="keyword">case</span> <span class="number">0</span>:
        <span class="comment">//master daemon(子进程)什么也不做</span>
        <span class="keyword">break</span>;

    <span class="keyword">default</span>:
        <span class="comment">//master前台进程(父进程)退出，以给控制终端一个“假象”，这个程序执行完了</span>
        <span class="built_in">exit</span>(<span class="number">0</span>);
    }
    <span class="comment">/*
    执行到这，说明最开始的“前台”进程已经退出了，这时得刷新下ngx_pid，以便后面ngx_create_pidfile用(用来优雅的重启)
    当然，有人问为什么main最开始就记录了，ngx_pid呢？那是因为nginx不一定会daemon形式启动，这样开始的进程就是master
    然而在这里，nginx将原来的前台master exit掉，然后master fork出来的，所以这里的ngx_pid就是就是daemon master的了。
    */</span>
    ngx_pid = ngx_getpid();
    <span class="comment">/*
    作为daemon只fork还是不够的，需要第二步，setsid，他的作用是让daemon成为真正的daemon
    1.会话组的老大; 2.进程组的老大; 3.不受任何控制终端控制
    */</span>
    <span class="keyword">if</span> (setsid() == -<span class="number">1</span>) {
        ngx_log_error(NGX_LOG_EMERG, <span class="built_in">log</span>, ngx_errno, <span class="string">"setsid() failed"</span>);
        <span class="keyword">return</span> NGX_ERROR;
    }
    <span class="comment">//umask(0)是为了让读写权限保持原来的状态</span>
    umask(<span class="number">0</span>);

    <span class="comment">//后面几句就是把STD的输入/输出/错误都输出到/dev/null，也就是什么也不输出</span>
    fd = open(<span class="string">"/dev/null"</span>, O_RDWR);
    <span class="keyword">if</span> (fd == -<span class="number">1</span>) {
        ngx_log_error(NGX_LOG_EMERG, <span class="built_in">log</span>, ngx_errno,
                      <span class="string">"open(\"/dev/null\") failed"</span>);
        <span class="keyword">return</span> NGX_ERROR;
    }

    <span class="keyword">if</span> (dup2(fd, STDIN_FILENO) == -<span class="number">1</span>) {
        ngx_log_error(NGX_LOG_EMERG, <span class="built_in">log</span>, ngx_errno, <span class="string">"dup2(STDIN) failed"</span>);
        <span class="keyword">return</span> NGX_ERROR;
    }

    <span class="keyword">if</span> (dup2(fd, STDOUT_FILENO) == -<span class="number">1</span>) {
        ngx_log_error(NGX_LOG_EMERG, <span class="built_in">log</span>, ngx_errno, <span class="string">"dup2(STDOUT) failed"</span>);
        <span class="keyword">return</span> NGX_ERROR;
    }

<span class="preprocessor">#if 0</span>
    <span class="keyword">if</span> (dup2(fd, STDERR_FILENO) == -<span class="number">1</span>) {
        ngx_log_error(NGX_LOG_EMERG, <span class="built_in">log</span>, ngx_errno, <span class="string">"dup2(STDERR) failed"</span>);
        <span class="keyword">return</span> NGX_ERROR;
    }
<span class="preprocessor">#endif</span>

    <span class="keyword">if</span> (fd &gt; STDERR_FILENO) {
        <span class="keyword">if</span> (close(fd) == -<span class="number">1</span>) {
            ngx_log_error(NGX_LOG_EMERG, <span class="built_in">log</span>, ngx_errno, <span class="string">"close() failed"</span>);
            <span class="keyword">return</span> NGX_ERROR;
        }
    }

    <span class="keyword">return</span> NGX_OK;
}
</code></pre><p>守护进程指的是后台运行不与任何控制终端相联的进程，许多网络服务器都作为守护进程运行。那么，什么样的进程才是守护进程呢？2种方法:</p>
<pre><code>    1. 这个进程是“富二代“，由内核无终端启动;
    2. 是靠自己后天努力，这个后天努力需要借助setid的帮助，新建一个会话，这样这个进程就成老大了，而且不受任何终端控制。
</code></pre><p>注释已经写的很详细了，总结一下就是以下几步。</p>
<pre><code>    <span class="number">1</span>. <span class="keyword">fork</span>一个daemon进程，退出前台进程。
    <span class="number">2</span>. setsid 让daemon彻底脱离控制终端（如果没用这步的话，就会造成终端一退出，进程也就退了）
    <span class="number">3</span>. <span class="keyword">umask</span>(<span class="number">0</span>)
    <span class="number">4</span>. 不让他输入输出
    <span class="number">5</span>. 改变目录，避免父进程工作目录的影响（nginx没做）
    <span class="number">6</span>. 关闭没用的fd
</code></pre><p>这个是APUE中提到的6步。当然，也有人建议进行第二次fork，二次fork的原因是不让进程重新被终端控制。是这样的，如果一个进程是一个不属于任何一个终端的会话组的首进程，当这个进程打开终端的时候，系统就会为他分配一个终端，这样就惨了，它又要受终端控制了(一个会话组的首进程如果不属于任何终端，则该进程打开终端时会被分配终端，一个会话如果属于某个终端，就会有一个前台进程组)，也就做不成守护进程了。不过要是二次fork的话，daemon A fork 出来 daemon B，这个daemon B不是会话首进程，就不会被分配到终端控制了。但是nginx没做，我觉得可能是因为nginx不会作类似操作吧。<br>注：不过2次fork，要记得Sighnal(SIG_HUP, SIG_IGN)，否则daemon A作为首进程退出的时候，会告诉所有的小弟(包括B了)。</p>
<p>具体的守护进程参考UNP和APUE中的资料。</p>
<hr>
<h3 id="ngx_master_process_cycle"><a>5.ngx_master_process_cycle，mater干的活</a></h3>


<p>在完成main中的初始化后，我们的“初始化”旅程到了结尾，热身结束，开始重点。到调用这个函数的时候，nginx还是只有master进程的，作为master进程的开始工作，最终要的就是启动“work”进程。其实，很多软件都有master，work的概念，诸如Hadoop的jobtracker、tasktracker。master处理和用户的交互，然后work专心的去做业务，这样的话，master可以想象为一个管理者，work则是真正的工人。</p>
<p>屏蔽一下干扰</p>
<pre><code>sigemptyset(&amp;<span class="operator"><span class="keyword">set</span>);</span>
sigaddset(&amp;<span class="operator"><span class="keyword">set</span>, SIGCHLD);</span>
sigaddset(&amp;<span class="operator"><span class="keyword">set</span>, SIGALRM);</span>
sigaddset(&amp;<span class="operator"><span class="keyword">set</span>, SIGIO);</span>
sigaddset(&amp;<span class="operator"><span class="keyword">set</span>, SIGINT);</span>
sigaddset(&amp;<span class="operator"><span class="keyword">set</span>, ngx_signal_value(NGX_RECONFIGURE_SIGNAL));</span>
sigaddset(&amp;<span class="operator"><span class="keyword">set</span>, ngx_signal_value(NGX_REOPEN_SIGNAL));</span>
sigaddset(&amp;<span class="operator"><span class="keyword">set</span>, ngx_signal_value(NGX_NOACCEPT_SIGNAL));</span>
sigaddset(&amp;<span class="operator"><span class="keyword">set</span>, ngx_signal_value(NGX_TERMINATE_SIGNAL));</span>
sigaddset(&amp;<span class="operator"><span class="keyword">set</span>, ngx_signal_value(NGX_SHUTDOWN_SIGNAL));</span>
sigaddset(&amp;<span class="operator"><span class="keyword">set</span>, ngx_signal_value(NGX_CHANGEBIN_SIGNAL));</span>

if (sigprocmask(SIG_BLOCK, &amp;<span class="operator"><span class="keyword">set</span>, <span class="keyword">NULL</span>) == -<span class="number">1</span>) {
    ngx_log_error(NGX_LOG_ALERT, cycle-&gt;log, ngx_errno,
                  <span class="string">"sigprocmask() failed"</span>);</span>
}

sigemptyset(&amp;<span class="operator"><span class="keyword">set</span>);</span>
</code></pre><p>最开始的工作就是做一些信号处理的工作，首先将系统信号，nginx自定义的信号加入’sigset_t set;’信号集中，然后调用sigprocmask进行信号的屏蔽，函数为 ‘sigprocmask(SIG_BLOCK, &amp;set, NULL)’ ，第一个参数为SIG_BLOCK意思就是按照set屏蔽信号，也就是说把之前通过 ‘sigaddset’ 的10个信号都屏蔽掉了，以防止在fork Work的过程中发生的意外。</p>
<hr>
<h3 id="ngx_master"><a>6.master开始工作</a></h3>

<p>master进程在屏蔽完信号干扰后，便调用了ngx_start_worker_processes来启动worker进程，这个函数的核心就是一个for循环，调用ccf-&gt;worker_processes次ngx_spawn_process函数，fork了ccf-&gt;worker_processes个worker。</p>
<p>ngx_spawn_process则是真正fork worker的函数。</p>
<pre><code>pid = fork();

<span class="keyword">switch</span> (pid) {

<span class="keyword">case</span> -<span class="number">1</span>:
    ngx_log_error(NGX_LOG_ALERT, cycle-&gt;<span class="keyword">log</span>, ngx_errno,
                  <span class="string">"fork() failed while spawning \"%s\""</span>, name);
    ngx_close_channel(ngx_processes[s].channel, cycle-&gt;<span class="keyword">log</span>);
    <span class="keyword">return</span> NGX_INVALID_PID;

<span class="keyword">case</span> <span class="number">0</span>:
    ngx_pid = ngx_getpid();
    <span class="keyword">proc</span>(cycle, data);
    <span class="keyword">break</span>;

<span class="keyword">default</span>:
    <span class="keyword">break</span>;
}
</code></pre><p>又是熟悉的fork了，能进入case 0的就是worker进程。而master进程则继续ngx_master_process_cycle，在worker都被master fork出来之后，master就要正常开始他的工作了</p>
<pre><code><span class="keyword">for</span> ( ;; ) {
// <span class="keyword">...</span> 
    sigsuspend(&amp;set);
// <span class="keyword">...</span>
}
</code></pre><p>这个就是master的工作框架，简单吧？就是休眠，等信号，做事儿，再休眠，等信号，做事儿。sigsuspend(&amp;set);就是让进程休眠，直到有信号的时候，去处理。</p>
<p>在main开始初始化的时候，就通过’ngx_init_signals’对每个信号的回调函数进行<a href="./#siginit">初始化</a>，也就是说，每次信号来了都会调用 ‘ngx_signal_handler’ 去设全局的flag，如果有信号了，master的 ‘ngx_master_process_cycle’ 就会对这些全局flag进行对应的处理。</p>
<p>最后，总结一下master的工作，就是先把信号都屏蔽了，然后去fork worker进程，fork完work以后，master就进入信号处理的循环了，利用sigsuspend等信号，等到信号就处理，处理完了再sigsusoend，如此循环，完成伟大的幕后工作。</p>
<hr>
<h3 id="ngx_worker"><a>7.ngx_worker_process_cycle，worker开始工作</a></h3>


<p>worker开始工作的真正时候，应该是在master调用ngx_spawn_process之后的，master传入的proc参数就是ngx_worker_process_cycle函数指针，再回到刚才master中那个fork的过程，case 0的时候调用了proc(cycle, data);也就是相当与调用了ngx_worker_process_cycle，这样worker的工作也马不停蹄的开始了。</p>
<p>首先，惯例，进行初始化，ngx_worker_process_init，这里面就包括了自身的初始化，还有去除一下从master过来的没用的东西，比如sigprocmask一下，把之前master的屏蔽掉信号都开启了。这样，才能对master的信号进行处理，以便完成master和work的进程间的通信。</p>
<p>然后就开始真正的工作了，也是一个大循环。</p>
<pre><code><span class="keyword">for</span> ( ;; ) {
// <span class="keyword">...</span> 
    ngx_process_events_and_timers(cycle)
// <span class="keyword">...</span>
}
</code></pre><p>到此worker的框架也就这样了，然后for循环的底部会有一些对master发来的信号的处理。</p>
<p>至此，master和worker的初始化工作以及基本的框架算是完了，经过上面的学习以后，发现对nginx的整个流程有了一个大概的认识。学习初始化的过程中，我学到了daemon，多进程，信号处理等基本知识。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2014/03/13/nginxstart/" data-id="230h9qmaxpgnndzn" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2014/03/16/nginxchannel/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          nginx中channel机制
        
      </div>
    </a>
  
  
    <a href="/2013/02/27/gdb-record/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">JNI调试方法</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/In XiDian/">In XiDian</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux Skill/">Linux Skill</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Some record/">Some record</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/nginx源码学习/">nginx源码学习</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/vim/">vim</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/算法学习/">算法学习</a><span class="category-list-count">1</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/About Blog/">About Blog</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Minds/">Minds</a><span class="tag-list-count">6</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/About Blog/" style="font-size: 10.00px;">About Blog</a><a href="/tags/Minds/" style="font-size: 20.00px;">Minds</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/04">April 2014</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/03">March 2014</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/02">February 2013</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/12">December 2012</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/11">November 2012</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2011/05">May 2011</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2011/03">March 2011</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2010/10">October 2010</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2010/07">July 2010</a><span class="archive-list-count">1</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recents</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2014/04/18/minheap/">最小堆</a>
          </li>
        
          <li>
            <a href="/2014/04/17/nginxconnections/">nginx的连接池</a>
          </li>
        
          <li>
            <a href="/2014/04/01/nginxaccept/">nginx建立连接过程分析</a>
          </li>
        
          <li>
            <a href="/2014/03/26/nginxevent/">nginx的事件主体分析</a>
          </li>
        
          <li>
            <a href="/2014/03/21/nginxeventinit/">nginx的事件初始化与框架</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2014 John Doe<br>
      Powered by <a href="http://zespia.tw/hexo/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>


<script type="text/javascript" src="/js/script.js"></script>
  </div>
</body>
</html>